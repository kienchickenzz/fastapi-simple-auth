from typing import Annotated

from fastapi import APIRouter, Security, Depends
from fastapi.security import OAuth2PasswordRequestForm

from src.base.dependency_injection import Injects
from src.base.exception.repository.base import NotFoundException

# local imports
from src.auth.util.main import (
    authenticate, password_hash_match, 
    create_access_token, create_refresh_token, verify_token
)
from src.auth.doc import Tags
from src.auth.database.repository.jwt_token import JWTRepository
from src.auth.database.repository.account import AccountRepository 
from src.auth.dto.token import AccessTokenResponse, RefreshTokenRequest
from src.auth.exception.api.account_exception import(
    AnalyzerException, AccountBadRequestException, AccountNotFoundException, AccountUnAuthorizedException
)

router = APIRouter(tags=[Tags.ACCOUNT], prefix="/v1/account/authentication")


# region: token
@router.post(
    path="/generate_token",
    summary="Get token",
    description="Get new access token (login)",
    status_code=200,
    responses={
        400: {"model": AccountBadRequestException.model},
        401: {"model": AccountUnAuthorizedException.model},
        404: {"model": AccountNotFoundException.model},
        500: {"model": AnalyzerException.model},
    },
)
async def generate_token(
    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],
    account_repository: AccountRepository = Injects("account_repository"),
    jwt_repository: JWTRepository = Injects("jwt_repository")
) -> AccessTokenResponse:
    try:
        account_entities = await account_repository.get_by_email(email=form_data.username)
    except NotFoundException:
        raise AccountUnAuthorizedException()
    
    if len(account_entities) == 0:
        raise AccountNotFoundException()
    if len(account_entities) != 1:
        # there cannot be more than one account with this email!
        raise AnalyzerException()  # FIXME: make this custom exception
    else:
        account_entity = account_entities[0]

    if not password_hash_match(form_data.password, account_entity.hashed_password):
        raise AccountUnAuthorizedException()
    
    # NOTE: only one device can be logged in at any given time because we
    # clear the repository for the account per each login
    await jwt_repository.delete_by_account_id(account_id=account_entity.id)
    
    access_token = create_access_token(
        data={"sub": str(account_entity.id)}
    )
    refresh_token = create_refresh_token(
        data={"sub": str(account_entity.id)}
    )

    jwt_entity = await jwt_repository.create(
        values={
            "account_id": account_entity.id,
            "access_token": access_token,
            "refresh_token": refresh_token,
        }
    )

    return AccessTokenResponse(
        access_token=jwt_entity.access_token,
        refresh_token=jwt_entity.refresh_token,
    )


@router.post(
    path="/refresh_token",
    summary="Refresh token",
    description="Refresh the access token",
    status_code=200,
    responses={
        400: {"model": AccountBadRequestException.model},
        401: {"model": AccountUnAuthorizedException.model},
        500: {"model": AnalyzerException.model},
    },
)
async def refresh_token(
    request: RefreshTokenRequest,
    authenticated_account_id: int = Security(authenticate),
    jwt_repository: JWTRepository = Injects("jwt_repository")
) -> AccessTokenResponse:
    account_id = verify_token(token=request.refresh_token, type="refresh")
    if authenticated_account_id != account_id:
        raise AccountUnAuthorizedException()

    # because refresh token is generated by us then it is guaranteed
    # that account ID is valid and not corrupted - we don't need to fetch account model again

    access_token = create_access_token(
        data={"sub": str(account_id)}
    )
    refresh_token = create_refresh_token(
        data={"sub": str(account_id)}
    )

    jwt_entities = await jwt_repository.update_by_account_id(
        account_id=account_id,
        values={
            "access_token": access_token,
            "refresh_token": refresh_token,
        }
    )

    if len(jwt_entities) != 1:
        # there cannot be more than one JWT entity per account!
        raise AnalyzerException()  # FIXME: make this custom exception
    else:
        jwt_entity = jwt_entities[0]

    return AccessTokenResponse(
        access_token=jwt_entity.access_token,
        refresh_token=jwt_entity.refresh_token,
    )


@router.post(
    path="/terminate_token",
    summary="Terminate token",
    description="Invalidate refresh and access token (logout)",
    status_code=204,
    responses={
        400: {"model": AccountBadRequestException.model},
        401: {"model": AccountUnAuthorizedException.model},
        500: {"model": AnalyzerException.model},
    },
)
async def terminate_token(
    account_id: int = Security(authenticate),
    jwt_repository: JWTRepository = Injects("jwt_repository")
) -> None:
    await jwt_repository.delete_by_account_id(account_id=account_id)
# endregion: token